# coding: utf-8

"""
    merged spec

    merged spec

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.account_info import AccountInfo
from openapi_client.models.country_code import CountryCode
from typing import Optional, Set
from typing_extensions import Self

class Profile(BaseModel):
    """
    Profile
    """ # noqa: E501
    profile_id: Optional[StrictInt] = Field(default=None, alias="profileId")
    country_code: Optional[CountryCode] = Field(default=None, alias="countryCode")
    currency_code: Optional[StrictStr] = Field(default=None, description="The currency used for all monetary values for entities under this profile. |Region|`countryCode`|Country Name|`currencyCode`| |-----|------|------|------| |NA|BR|Brazil|BRL| |NA|CA|Canada|CAD| |NA|MX|Mexico|MXN| |NA|US|United States|USD| |EU|AE|United Arab Emirates|AED| |EU|BE|Belgium|EUR| |EU|DE|Germany|EUR| |EU|EG|Egypt|EGP| |EU|ES|Spain|EUR| |EU|FR|France|EUR| |EU|IN|India|INR| |EU|IT|Italy|EUR| |EU|NL|The Netherlands|EUR| |EU|PL|Poland|PLN| |EU|SA|Saudi Arabia|SAR| |EU|SE|Sweden|SEK| |EU|TR|Turkey|TRY| |EU|UK|United Kingdom|GBP| |EU|ZA| South Africa | ZAR| |FE|AU|Australia|AUD| |FE|JP|Japan|JPY| |FE|SG|Singapore|SGD|", alias="currencyCode")
    daily_budget: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Note that this field applies to Sponsored Product campaigns for seller type accounts only. Not supported for vendor type accounts.", alias="dailyBudget")
    timezone: Optional[StrictStr] = Field(default=None, description="The time zone used for all date-based campaign management and reporting. |Region|`countryCode`|Country Name|`timezone`| |------|-----|-----|------| |NA|BR|Brazil|America/Sao_Paulo| |NA|CA|Canada|America/Los_Angeles| |NA|MX|Mexico|America/Los_Angeles| |NA|US|United States|America/Los_Angeles| |EU|AE|United Arab Emirates|Asia/Dubai| |EU|BE|Belgium|Europe/Brussels| |EU|DE|Germany|Europe/Paris| |EU|EG|Egypt|Africa/Cairo| |EU|ES|Spain|Europe/Paris| |EU|FR|France|Europe/Paris| |EU|IN|India|Asia/Kolkata| |EU|IT|Italy|Europe/Paris| |EU|NL|The Netherlands|Europe/Amsterdam| |EU|PL|Poland|Europe/Warsaw| |EU|SA|Saudi Arabia|Asia/Riyadh| |EU|SE|Sweden|Europe/Stockholm| |EU|TR|Turkey|Europe/Istanbul| |EU|UK|United Kingdom|Europe/London| |EU|ZA| South Africa | Africa/Johannesburg | |FE|AU|Australia|Australia/Sydney| |FE|JP|Japan|Asia/Tokyo| |FE|SG|Singapore|Asia/Singapore|")
    account_info: Optional[AccountInfo] = Field(default=None, alias="accountInfo")
    __properties: ClassVar[List[str]] = ["profileId", "countryCode", "currencyCode", "dailyBudget", "timezone", "accountInfo"]

    @field_validator('currency_code')
    def currency_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['BRL', 'CAD', 'MXN', 'USD', 'AED', 'EUR', 'EGP', 'INR', 'PLN', 'SAR', 'SEK', 'TRY', 'GBP', 'AUD', 'JPY', 'SGD', 'ZAR']):
            raise ValueError("must be one of enum values ('BRL', 'CAD', 'MXN', 'USD', 'AED', 'EUR', 'EGP', 'INR', 'PLN', 'SAR', 'SEK', 'TRY', 'GBP', 'AUD', 'JPY', 'SGD', 'ZAR')")
        return value

    @field_validator('timezone')
    def timezone_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Africa/Cairo', 'America/Sao_Paulo', 'America/Los_Angeles', 'Asia/Dubai', 'Asia/Kolkata', 'Asia/Riyadh', 'Asia/Singapore', 'Asia/Tokyo', 'Australia/Sydney', 'Europe/Amsterdam', 'Europe/Istanbul', 'Europe/London', 'Europe/Paris', 'Europe/Stockholm', 'Europe/Warsaw', 'Europe/Brussels', 'Africa/Johannesburg']):
            raise ValueError("must be one of enum values ('Africa/Cairo', 'America/Sao_Paulo', 'America/Los_Angeles', 'Asia/Dubai', 'Asia/Kolkata', 'Asia/Riyadh', 'Asia/Singapore', 'Asia/Tokyo', 'Australia/Sydney', 'Europe/Amsterdam', 'Europe/Istanbul', 'Europe/London', 'Europe/Paris', 'Europe/Stockholm', 'Europe/Warsaw', 'Europe/Brussels', 'Africa/Johannesburg')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Profile from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "currency_code",
            "timezone",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of account_info
        if self.account_info:
            _dict['accountInfo'] = self.account_info.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Profile from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "profileId": obj.get("profileId"),
            "countryCode": obj.get("countryCode"),
            "currencyCode": obj.get("currencyCode"),
            "dailyBudget": obj.get("dailyBudget"),
            "timezone": obj.get("timezone"),
            "accountInfo": AccountInfo.from_dict(obj["accountInfo"]) if obj.get("accountInfo") is not None else None
        })
        return _obj


